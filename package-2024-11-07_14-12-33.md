## ./api/admin.py
```
from django.contrib import admin

# Register your models here.
```
## ./api/models.py
```
# api/models.py
from django.db import models
from django.contrib.auth.models import User  # Import the built-in User model
from django.conf import settings

class Session(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,  # Best practice: refer to the user model via settings
        on_delete=models.CASCADE,  # Ensures user's sessions are deleted with the user
        related_name='sessions'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Session {self.id} for user {self.user.username} started at {self.created_at}"

class Message(models.Model):
    # Fields
    session = models.ForeignKey(Session, related_name='messages', on_delete=models.CASCADE)
    text = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    from_user = models.BooleanField(default=True)  # True if from user, False if from system (LangChain)

    def __str__(self):
        return f"Message from {'User' if self.from_user else 'System'} at {self.timestamp}: {self.text[:50]}"
```
## ./api/serializers.py
```
# api/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User

class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(
        max_length=128,
        min_length=8,
        write_only=True,
    )
    password2 = serializers.CharField(
        max_length=128,
        min_length=8,
        write_only=True,
    )

    class Meta:
        model = User
        fields = ('username', 'email', 'password', 'password2')

    def validate(self, attrs):
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError({"password": "Password fields didn't match."})
        return attrs

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password']
        )
        return user

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email')
```
## ./api/migrations/0001_initial.py
```
# Generated by Django 4.2.16 on 2024-11-01 16:30

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Session',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='Message',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('text', models.TextField()),
                ('timestamp', models.DateTimeField(auto_now_add=True)),
                ('from_user', models.BooleanField(default=True)),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='api.session')),
            ],
        ),
    ]
```
## ./api/migrations/__init__.py
```
```
## ./api/langchain_logic.py
```
# api/langchain_logic.py
import os
from langchain_openai import ChatOpenAI


# Securely retrieve your OpenAI API key from environment variables
openai_api_key = os.environ.get('OPENAI_API_KEY')

# Initialize the OpenAI LLM with your API key and desired parameters
llm = ChatOpenAI(
    openai_api_key=openai_api_key,
    model_name='gpt-3.5-turbo',
    temperature=0.7
)

def process_message(conversation):
    """
    Send the conversation history to the language model and return the response text.
    """
    try:
        # Use the LLM to generate a response
        response = llm.invoke(conversation)  # Passing the conversation history
        # Access the content of the response
        if response:
            return response.content
        else:
            return "No response generated by the model."
    except Exception as e:
        print(f"An error occurred: {e}")
        return f"Sorry, an error occurred while processing your message. {str(e)}"```
## ./api/views.py
```
# api/views.py
from django.shortcuts import render
import json
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from .models import Session, Message
from .langchain_logic import process_message    # cspell: disable-line
from django.views.decorators.csrf import csrf_exempt
from langchain.schema import HumanMessage, AIMessage    # cspell: disable-line
from django.contrib.auth import authenticate, login, logout
from rest_framework.decorators import api_view, permission_classes, authentication_classes
from rest_framework.response import Response
from .serializers import RegisterSerializer
from rest_framework import status
from rest_framework.permissions import AllowAny
from rest_framework.permissions import IsAuthenticated
from rest_framework.authtoken.models import Token  # cspell: disable-line
from rest_framework.authentication import TokenAuthentication

@api_view(['POST'])
@permission_classes([AllowAny])  # Allow unauthenticated access
def login_view(request):
    username = request.data.get('username')
    password = request.data.get('password')
    user = authenticate(request, username=username, password=password)
    
    if user is not None:
        # Log the user in
        login(request, user)
        
        # Retrieve or create a token for the authenticated user
        token, created = Token.objects.get_or_create(user=user)
        
        # Return the token and user info in the response
        return Response({
            'status': 'success',
            'user_id': user.id,
            'token': token.key  # Send the token to the frontend
        })
    
    # If authentication failed
    return Response({'status': 'error', 'message': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)


@api_view(['POST'])
def logout_view(request):
    logout(request)
    return Response({'status': 'success'})

@api_view(['POST'])
@permission_classes([AllowAny])  # Allow unauthenticated access
def register_view(request):
    serializer = RegisterSerializer(data=request.data)
    if serializer.is_valid():
        user = serializer.save()
        return Response({'status': 'success', 'user_id': user.id}, status=201)
    return Response(serializer.errors, status=400)
# ---

@api_view(['POST'])
@permission_classes([IsAuthenticated])  # Ensure only authenticated users can create a session
def create_session(request):
    # Associate the session with the currently authenticated user
    session = Session.objects.create(user=request.user)
    return Response({'session_id': session.id}, status=201)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_session(request, session_id):
    try:
        session = Session.objects.get(id=session_id, user=request.user)
        messages = Message.objects.filter(session=session).values('id', 'text', 'timestamp', 'from_user')
        return JsonResponse({'session_id': session.id, 'messages': list(messages)}, status=200)
    except Session.DoesNotExist:
        return JsonResponse({'error': 'Session not found'}, status=404)


@api_view(['GET'])
@authentication_classes([TokenAuthentication])  # Specify TokenAuthentication
@permission_classes([IsAuthenticated])
def get_sessions(request):
    if request.user.is_authenticated:
        sessions = request.user.sessions.all().values('id', 'created_at')
        return JsonResponse({'sessions': list(sessions)}, status=200)
    else:
        return JsonResponse({'error': 'Authentication required'}, status=401)

@csrf_exempt
def messages(request, session_id):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            message_text = data['text']
            session = Session.objects.get(id=session_id)
        except (json.JSONDecodeError, KeyError, Session.DoesNotExist) as e:
            return JsonResponse({'error': 'Invalid request or session not found'}, status=400)

        # Save user message
        user_message = Message.objects.create(session=session, text=message_text, from_user=True)

        # Retrieve conversation history
        conversation_messages = Message.objects.filter(session=session).order_by('timestamp')

        # Construct the conversation history for the LLM
        conversation = []
        for msg in conversation_messages:
            if msg.from_user:
                conversation.append(HumanMessage(content=msg.text))
            else:
                conversation.append(AIMessage(content=msg.text))

        # Process message with LangChain, passing the conversation history
        response_text = process_message(conversation)

        # Save system response
        assistant_message = Message.objects.create(session=session, text=response_text, from_user=False)

        return JsonResponse({'message': response_text}, status=200)

    elif request.method == 'GET':
        messages = Message.objects.filter(session_id=session_id).values('id', 'text', 'timestamp', 'from_user')
        return JsonResponse({'messages': list(messages)}, status=200)
    else:
        return JsonResponse({'error': 'Method not allowed'}, status=405)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])  # Require authentication
def delete_session(request, session_id):
    try:
        session = Session.objects.get(id=session_id)
        session.delete()  # This will also delete all messages associated with the session due to the CASCADE delete
        return JsonResponse({'message': 'Session deleted successfully'}, status=204)
    except Session.DoesNotExist:
        return JsonResponse({'error': 'Session not found'}, status=404)```
## ./api/apps.py
```
from django.apps import AppConfig


class ApiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'api'
    
    def ready(self):
        import api.signals  # Ensures the signal is registered when the app is ready
```
## ./api/tests.py
```
from django.test import TestCase

# Create your tests here.
```
## ./api/auth_views.py
```
# api/auth_views.py
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from django.contrib.auth.models import User
from rest_framework import generics
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework_simplejwt.tokens import RefreshToken
from .serializers import RegisterSerializer

class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    permission_classes = (AllowAny,)
    serializer_class = RegisterSerializer
```
## ./api/signals.py
```
# api/signals.py

from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token
from django.contrib.auth.models import User

@receiver(post_save, sender=User)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    """
    Signal to automatically create an authentication token whenever a new user is created.
    """
    if created:
        Token.objects.create(user=instance)
```
## ./api/__init__.py
```
```
## ./api/urls.py
```
# api/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('sessions/', views.create_session, name='create_session'),
    path('sessions/all/', views.get_sessions, name='get_sessions'),
    path('sessions/<int:session_id>/', views.get_session, name='get_session'),
    path('sessions/<int:session_id>/messages/', views.messages, name='messages'),  # Handles both GET and POST for messages
    # Delete Session
    path('sessions/<int:session_id>/delete/', views.delete_session, name='delete_session'),
    # Authentication paths
    path('login/', views.login_view, name='login'),
    path('logout/', views.logout_view, name='logout'),
    path('register/', views.register_view, name='register'),
]
```
## ./manage.py
```
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'llama_pipeline_django.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```
## ./llama_pipeline_django/settings.py
```
"""
Django settings for llama_pipeline_django project.

Generated by 'django-admin startproject' using Django 5.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-yyaum5%3c_)ybmdazh=r9y(y52sw5%m2o&zlw+@c6*um_*l5mp'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

CORS_ALLOW_ALL_ORIGINS = True

CORS_ALLOWED_ORIGINS = [
    'http://localhost:5173',  # Vite's default port
]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'api.apps.ApiConfig',
    'corsheaders',
    'rest_framework',
    'rest_framework.authtoken',  # Required for TokenAuthentication
    'djoser',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'llama_pipeline_django.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'llama_pipeline_django.wsgi.application'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.TokenAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

DJOSER = {
    'LOGIN_FIELD': 'username',
    'USER_CREATE_PASSWORD_RETYPE': True,
    'SERIALIZERS': {
        'user_create': 'api.serializers.RegisterSerializer',
        'user': 'api.serializers.UserSerializer',
    },
}

# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
```
## ./llama_pipeline_django/wsgi.py
```
"""
WSGI config for llama_pipeline_django project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'llama_pipeline_django.settings')

application = get_wsgi_application()
```
## ./llama_pipeline_django/__init__.py
```
```
## ./llama_pipeline_django/asgi.py
```
"""
ASGI config for llama_pipeline_django project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'llama_pipeline_django.settings')

application = get_asgi_application()
```
## ./llama_pipeline_django/urls.py
```
"""
URL configuration for llama_pipeline_django project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('api.urls')),  # Includes the API app urls under the 'api/' prefix
]```
